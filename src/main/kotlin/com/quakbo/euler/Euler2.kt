package com.quakbo.euler

/*
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */

private fun fibonacci(): Sequence<Int> {
    return generateSequence(
            Pair(0, 1), { Pair(it.second, it.first + it.second) }).map { it.first }
}

private const val limit = 4_000_000

fun main(args: Array<String>) {
    println(fibonacci()
            .takeWhile { it < limit }
            .filter { it % 2 == 0 }
            .sum())
}

/*
https://kotlinlang.org/docs/reference/visibility-modifiers.html

Notice that fibonacci() returns type Sequence<Int>.  Kotlin does not differentiate between Integer and int, it only has Int, Long, etc.
They are always stored as jvm primitives unless we need nullability (Int?) or when using generics.  In those cases the primitive values are boxed.
Boxing of primitive values does NOT necessarily preserve object identity.

    val a: Int = 10000
    print(a === a) // Prints 'true'
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a
    print(boxedA === anotherBoxedA) // !!!Prints 'false'!!!

Structural equality is == (double equals) and !=.  This is calling .equals under the hood!

    a?.equals(b) ?: (b === null)

    i.e., if a is not null, it calls the equals(Any?) function, otherwise (i.e. a is null) it checks that b is referentially equal to null.

Referential equality is === (triple equals) and !==.  Evaluates to true iff the two operands evaluate to the same object.

Nullability is easier to deal with in Kotlin.  For instance, as soon as you null-check a variable, subsequent access of that variable is automatically cast to
the correct type after the check.

    val foo: String? = getNullableString()
    if (foo == null) {
        println("Crap, it was null")
    }

    println("The string said, $foo")

This happens when type checking too.

    fun getStringLength(obj: Any): Int? {
        if (obj is String) {
            // `obj` is automatically cast to `String` in this branch.
            return obj.length
        }

        // `obj` is still of type `Any` outside of the type-checked branch
        return null
    }
 */